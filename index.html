<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Casino Royale: Siêu Phẩm Nặn Tài Xỉu 3D</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Arial', sans-serif; }
        #game-ui { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 10; color: white; }
        .glass-panel { background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); border: 1px solid rgba(255,215,0,0.3); border-radius: 15px; pointer-events: auto; }
        .info-bar { position: absolute; top: 20px; left: 20px; padding: 15px; }
        .status-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -150%); font-size: 40px; color: gold; font-weight: bold; text-shadow: 0 0 15px #000; text-align: center; }
        .controls { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; }
        .btn-action { padding: 20px 40px; font-size: 24px; cursor: pointer; border-radius: 50px; border: none; font-weight: bold; transition: 0.3s; }
        .btn-shake { background: linear-gradient(to bottom, #f1c40f, #f39c12); color: black; box-shadow: 0 5px 20px rgba(241,196,15,0.4); }
        .btn-shake:disabled { background: #555; color: #888; cursor: not-allowed; }
        #instruction { position: absolute; bottom: 180px; width: 100%; text-align: center; color: #00ff00; font-weight: bold; display: none; }
    </style>
</head>
<body>

<div id="game-ui">
    <div class="info-bar glass-panel">
        <div>SỐ DƯ: <span id="balance" style="color: #f1c40f;">10,000,000 $</span></div>
        <div id="bot-status" style="font-size: 12px; margin-top: 5px;">Bot Telegram: <span style="color: #0f0;">Kết nối</span></div>
    </div>

    <div id="status" class="status-msg">CHỜ ĐẶT CƯỢC...</div>
    <div id="instruction">DÙNG CHUỘT KÉO BÁT ĐỂ NẶN!</div>

    <div class="controls">
        <button id="shakeBtn" class="btn-action btn-shake glass-panel" onclick="startShake()">ÚP BÁT & LẮC</button>
    </div>
</div>

<canvas id="canvas3d"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script type="module">
    // --- CONFIG ---
    const BOT_TOKEN = '8564750082:AAGkVvtYyRBbsD9xkAXkmiadLiE_kmk_zfs';
    let scene, camera, renderer, world;
    let diceArray = [], bowlMesh, bowlBody;
    let gameState = 'WAITING'; // WAITING, SHAKING, SQUEEZING, FINISHED
    let isDragging = false;
    let initialBowlPos = { y: 1.6 };

    // --- MAPPING GÓC QUAY (BỊP) ---
    const FACE_QUATS = {
        1: [0, 0, 0, 1],
        2: [-0.707, 0, 0, 0.707],
        3: [0, 0, 0.707, 0.707],
        4: [0, 0, -0.707, 0.707],
        5: [0.707, 0, 0, 0.707],
        6: [1, 0, 0, 0]
    };

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, 12);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas3d'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a0a);
        renderer.shadowMap.enabled = true;

        world = new CANNON.World();
        world.gravity.set(0, -30, 0);

        // Ánh sáng
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        const spot = new THREE.SpotLight(0xffd700, 1);
        spot.position.set(0, 20, 10);
        spot.castShadow = true;
        scene.add(spot);

        createTable();
        createBowl();
        for(let i=0; i<3; i++) createDice(i);

        window.addEventListener('mousedown', onPointerDown);
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        
        animate();
    }

    function createTable() {
        const mesh = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 1, 64), new THREE.MeshStandardMaterial({ color: 0x111, metalness: 0.9 }));
        mesh.receiveShadow = true;
        scene.add(mesh);
        const body = new CANNON.Body({ mass: 0, shape: new CANNON.Cylinder(10, 10, 1, 64) });
        world.addBody(body);
    }

    function createBowl() {
        const geometry = new THREE.CylinderGeometry(5, 5.5, 4, 32, 1, true); // Open end
        const material = new THREE.MeshStandardMaterial({ color: 0x333, metalness: 1, roughness: 0.1, side: THREE.DoubleSide });
        bowlMesh = new THREE.Mesh(geometry, material);
        bowlMesh.position.y = 1.6;
        scene.add(bowlMesh);

        bowlBody = new CANNON.Body({ mass: 0, shape: new CANNON.Cylinder(5.5, 5.5, 4, 32) });
        bowlBody.position.set(0, 1.6, 0);
        world.addBody(bowlBody);
    }

    function createDice(i) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,1.2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        mesh.castShadow = true;
        scene.add(mesh);
        const body = new CANNON.Body({ mass: 1, shape: new CANNON.Box(new CANNON.Vec3(0.6,0.6,0.6)) });
        body.position.set(i*1.5 - 1.5, 1, 0);
        world.addBody(body);
        diceArray.push({ mesh, body });
    }

    // --- LOGIC ĐIỀU KHIỂN ---
    async function fetchResult() {
        try {
            const r = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getUpdates?offset=-1`);
            const d = await r.json();
            if(d.ok && d.result.length > 0) {
                return d.result[0].message.text.split(',').map(Number);
            }
        } catch(e) {}
        return null;
    }

    window.startShake = async function() {
        if(gameState !== 'WAITING') return;
        
        document.getElementById('status').innerText = "ĐANG LẮC...";
        document.getElementById('shakeBtn').disabled = true;
        
        // Úp bát xuống
        bowlMesh.position.y = 1.6;
        bowlBody.position.y = 1.6;

        const control = await fetchResult();
        
        diceArray.forEach((dice, i) => {
            dice.body.position.set(Math.random(), 5 + i, Math.random());
            if(control && control.length === 3) {
                const q = FACE_QUATS[control[i]];
                dice.body.quaternion.set(q[0], q[1], q[2], q[3]);
                dice.body.angularVelocity.set(0, 10, 0);
            } else {
                dice.body.angularVelocity.set(Math.random()*20, Math.random()*20, Math.random()*20);
            }
        });

        setTimeout(() => {
            gameState = 'SQUEEZING';
            document.getElementById('status').innerText = "HÃY NẶN KẾT QUẢ!";
            document.getElementById('instruction').style.display = 'block';
        }, 3000);
    }

    // --- LOGIC NẶN (DRAG & DROP) ---
    function onPointerDown(e) {
        if(gameState === 'SQUEEZING') isDragging = true;
    }

    function onPointerMove(e) {
        if(isDragging && gameState === 'SQUEEZING') {
            const moveY = e.movementY * 0.02;
            const moveX = e.movementX * 0.02;
            
            bowlMesh.position.y = Math.max(1.6, bowlMesh.position.y - moveY);
            bowlMesh.position.x += moveX;
            bowlMesh.position.z += e.movementY * 0.01; // Kéo ra xa

            if(bowlMesh.position.y > 6 || Math.abs(bowlMesh.position.x) > 4) {
                finishGame();
            }
        }
    }

    function onPointerUp() { isDragging = false; }

    function finishGame() {
        gameState = 'FINISHED';
        document.getElementById('instruction').style.display = 'none';
        
        // Tính điểm
        let total = 0;
        // Logic tính mặt ngửa thực tế từ Physics (đơn giản hóa cho bản demo)
        document.getElementById('status').innerText = "KẾT QUẢ XONG!";
        
        setTimeout(() => {
            // Reset
            bowlMesh.position.set(0, 1.6, 0);
            gameState = 'WAITING';
            document.getElementById('status').innerText = "CHỜ ĐẶT CƯỢC...";
            document.getElementById('shakeBtn').disabled = false;
        }, 5000);
    }

    function animate() {
        requestAnimationFrame(animate);
        world.step(1/60);
        diceArray.forEach(d => {
            d.mesh.position.copy(d.body.position);
            d.mesh.quaternion.copy(d.body.quaternion);
        });
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>
